import xml.etree.ElementTree as ET
from typing import List, Dict, Union, Optional
import config.global_word_book as gwb  # Импортируем global_word_book

def extract_c4_names(drawio_file_path: str, imena_uslug_file: str = "config.imena_uslug") -> List[str]:
    """
    Извлекает значения атрибута 'B____c4Technology' из указанного файла Drawio, сравнивает их с эталоном
    из файла IMENA_USLUG и возвращает отфильтрованный список, отдавая предпочтение наиболее точному совпадению.
    Также извлекает и сохраняет связанные атрибуты в global_word_book для *всех* найденных B____c4Technology.

    Args:
        drawio_file_path (str): Путь к файлу .drawio.
        imena_uslug_file (str, optional): Путь к файлу с эталонными именами услуг.
            По умолчанию "config.imena_uslug".

    Returns:
        List[str]: Список строк, представляющих отфильтрованные значения атрибутов 'B____c4Technology',
                    или пустой список в случае ошибки.
    """
    c4_technologies: List[str] = []
    filtered_c4_technologies: List[str] = []
    service_counter: int = 1  # Инициализируем счетчик для уникальных ключей

    # 1. Обработка файла Drawio и разбор XML
    try:
        with open(drawio_file_path, 'r', encoding='utf-8') as f:
            xml_content = f.read()
        root = ET.fromstring(xml_content)
    except FileNotFoundError:
        print(f"❌ Ошибка: Файл не найден по пути: {drawio_file_path}")
        return []
    except ET.ParseError as e:
        print(f"❌ Ошибка XML: Ошибка разбора XML в файле: {e}")
        return []
    except Exception as e:
        print(f"❌ Ошибка при работе с файлом: {e}")
        return []

    # 2. Выбор листа (диаграммы)
    diagrams = root.findall("diagram")
    if not diagrams:
        print("❌ Ошибка: В файле не найдено ни одного листа (диаграммы).")
        return []

    selected_diagram = None
    if gwb.SELECTED_SHEET_NAME:  # Используем имя листа из global_word_book
        for diagram in diagrams:
            if diagram.attrib.get("name") == gwb.SELECTED_SHEET_NAME:
                selected_diagram = diagram
                break
        if selected_diagram is None:
            print(f"❌ Ошибка: Лист с именем '{gwb.SELECTED_SHEET_NAME}' не найден в файле.")
            return []
    else:
        print("❌ Ошибка: Имя листа не выбрано.  Установите 'SELECTED_SHEET_NAME' в global_word_book.")
        return []

    diagram_name = selected_diagram.attrib.get("name", "(Без имени)")
    print(f"✅ Выбран лист: \"{diagram_name}\"")

    xml_content_of_selected_diagram = ET.tostring(selected_diagram, encoding='unicode')
    try:
        diagram_root = ET.fromstring(xml_content_of_selected_diagram)
    except ET.ParseError as e:
        print(f"❌ Ошибка XML: Ошибка разбора XML содержимого листа: {e}")
        return []

    # 3. Извлечение B____c4Technology и других атрибутов из выбранного листа
    elements_with_c4_tech = []
    for element in diagram_root.iter():
        if 'B____c4Technology' in element.attrib:
            c4_technologies.append(element.attrib['B____c4Technology'])
            elements_with_c4_tech.append(element) # Сохраняем элемент для дальнейшей обработки

    # 4. Загрузка эталонных имен услуг из файла
    try:
        from config.imena_uslug import IMENA_USLUG
        imena_uslug_data: Dict[str, Union[str, int, Dict[str, Union[str, int]]]] = IMENA_USLUG  # Явное указание типа
    except ImportError as e:
        print(f"❌ Ошибка: Не удалось импортировать данные из файла: {e}")
        return []
    except Exception as e:
        print(f"❌ Ошибка при чтении данных из файла {imena_uslug_file}: {e}")
        return []

    # 5. Фильтрация и форматирование имен и извлечение доп. атрибутов
    for c4_tech, element in zip(c4_technologies, elements_with_c4_tech): # Итерируемся по c4_technologies и соответствующим элементам
        if not c4_tech:  # Проверяем, что B____c4Technology не пустая строка
            print("❌ Ошибка: Атрибут B____c4Technology пуст.")
            continue  # Переходим к следующей итерации цикла, не обрабатывая дальше
        best_match: Optional[str] = None
        best_match_length: int = 0  # Длина лучшего совпадения
        for key, value in imena_uslug_data.items():
            if key in c4_tech:
                if best_match is None or len(key) > best_match_length:
                    best_match_length = len(key)
                    if isinstance(value, dict):
                        # value - это словарь, извлекаем "человеческое" имя услуги
                        human_name = list(value.keys())[0]
                        best_match = human_name
                        # Получаем значения других атрибутов и сохраняем в global_word_book
                        element_dict = element.attrib
                        gwb.c4_tech_data[service_counter] = {  # Используем числовой ключ
                            "service_name": human_name, # Сохраняем и человекочитаемое имя
                            "E____CPU": element_dict.get("E____CPU", 0),
                            "F____RAM": element_dict.get("F____RAM", 0),
                            "G____SSD": element_dict.get("G____SSD", 0),
                            "H____HDD_Fast": element_dict.get("H____HDD_Fast", 0),
                            "I____HDD_Slow": element_dict.get("I____HDD_Slow", 0),
                            "J____OS_type": element_dict.get("J____OS_type", 0),
                            "K____OS_count": element_dict.get("K____OS_count", 0),
                        }
                    elif isinstance(value, (int, str)):
                        # value - это int или str
                        best_match = key
                        element_dict = element.attrib
                        gwb.c4_tech_data[service_counter] = {  # Используем числовой ключ
                            "service_name": key, # Сохраняем и человекочитаемое имя
                            "E____CPU": element_dict.get("E____CPU", 0),
                            "F____RAM": element_dict.get("F____RAM", 0),
                            "G____SSD": element_dict.get("G____SSD", 0),
                            "H____HDD_Fast": element_dict.get("H____HDD_Fast", 0),
                            "I____HDD_Slow": element_dict.get("I____HDD_Slow", 0),
                            "J____OS_type": element_dict.get("J____OS_type", 0),
                            "K____OS_count": element_dict.get("K____OS_count", 0),
                        }
                    else:
                        print(
                            f"⚠️  Предупреждение: Неожиданный тип значения для '{key}'.  Пропускаем фильтрацию для этого элемента."
                        )
                        best_match = key  # Добавляем элемент без фильтрации
        if best_match:
            filtered_c4_technologies.append(best_match)
        service_counter += 1  # Увеличиваем счетчик после обработки каждой услуги
    return filtered_c4_technologies
